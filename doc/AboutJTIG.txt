About JTIGImplementationToplevel class: parser.early.JTIGParser.main(String[]):- loads properties- tokenises sentence with MorphAdorner- reads grammar- parses tokenized sentenceReading a grammar: from XML or Lisp- automatically creates internalized etree structure- and creates a Lexicon class which keeps a list of elementaryTrees and a index using the anchors	- cascaded hashmap for storing MWL	Main parser class: parser.early.JTIGParser.parseSentence(String, Token[]):- es wird der Parser ParseRun() initialisiert	- phase-1: lexical lookup in order to get sentence relevant trees	- parser.lookup.Lookup.findlongestmatches(Token[], Lexicon):		to handle MWL - could be improved by NEMEXA	- parser.lookup.ActivatedLexicon: stores selected elementary trees		- etrees are already in internalized form		- list of layers: cfg plus Gorn number		- grammar.treeinsertion.ElementaryTree	- then call ParseRun.Call	- performs phase-2	- init chart and agenda	- call main loop until agenda is empty (or first answer is found)	- processes forest to compute		- independent derivation tree		- dependent derivation		- parse tree		Issues still unclear to me:● How is probability processing implemented● How to select best reading onlyAgenda:Agenda is implemented as a priorityQueue :  	lower weighted elements are selected first.parser.early.components.agenda: 	contains ItemComparator, which is used to sort elements.	A comparator that puts newest elements always on top of heap:       public int compare(Item a, Item b) {        	result = a.getID() - b.getID();		return result;}	Grammatik-Extraktion	Erzeuge Testgrammatiken ohne Interpunktion und so, um größere Grammatiken testen zu können.	Daher: Grammatikextraktion auch in java reimplementieren	Bedeutet: 		conll2penn & extraction oder direkt dependenz-artige LTIGs ?	Integration von Uniform Dependency Grammars	POS-TaggerHow to prune lexical lookup ?Wie Supertagging und almost parsing realisieren ?	